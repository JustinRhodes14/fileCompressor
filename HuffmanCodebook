00		
010000000000	number
010000000001	//recursive
0100000000100	normal,
0100000000101	//reads
010000000011	t1
0100000001000	printf("error
0100000001001	compress(temp,huffBook);
0100000001010	printhuffTree(Node*,int*,int,int);//stores
0100000001011	compress,
010000000110	t1->word
0100000001110	name\n");
0100000001111	negative
01000000100	result
010000001010	lesser,
0100000010110	temp2->binary;
0100000010111	(compareString(word,"\t\0")
01000000110	buffer[101];
0100000011100	issues
0100000011101	bstSearch(char*);//searches
0100000011110	//call
0100000011111	bstNode
010000010000	(strlen(holder)
0100000100010	as
0100000100011	heapSize++;
010000010010	codeWord
010000010011	strlen(str1);
0100000101000	then
0100000101001	index;++i)
010000010101	that
010000010110	t2->freq
0100000101110	must
0100000101111	name
0100000110000	item1
0100000110001	//compares
0100000110010	(compareString(word,"\t\t\t\0")
0100000110011	item2.isTree)
01000001101	tableInit(1000);
010000011100	t2->left
0100000111010	mode
0100000111011	mode,
0100000111100	mode,char*
0100000111101	//otherwise,
010000011111	close(fd2);
0100001000000	(dir->d_type
0100001000001	bytestoWrite
010000100001	spaceDelim)
0100001000100	{//recursive
0100001000101	NULL;//not
010000100011	frequency,
0100001001000	writeTo(decompressed,"\n\0");
0100001001001	hashInsert(char*
0100001001010	writeTo(decompressed,word);
0100001001011	without
010000100110	combineString(path,"/");
010000100111	writes
0100001010000	printBst(ptr->left);
0100001010001	((dir
0100001010010	Could
0100001010011	files\n",argv[2]);
010000101010	following
0100001010110	i--)
0100001010111	important
0100001011000	_heapItem
0100001011001	hashSearch("\t\t\t\0",NULL,true);//three
0100001011010	writing
0100001011011	valid
01000010111	(argv[2][0]
01000011000	already
010000110010	sum
010000110011	hashcodeWord(word);
0100001101000	//two
0100001101001	path
0100001101010	((argv[1][1]
0100001101011	//three
0100001101100	//Produces
0100001101101	binary;
0100001101110	toFree)
0100001101111	binary)
0100001110	used\n");
010000111100	open("./HuffmanCodebook",
0100001111010	hashcodeWord(char*
0100001111011	alphabetical
010000111110	//The
0100001111110	huffmanTree;//used
0100001111111	(compareString(substring(argv[2],(strlen(argv[2])-4),-1),".hcz\0")
010001000000	literal
0100010000010	certain
0100010000011	listDirectories(argv[3],0,NULL);
0100010000100	newLine
0100010000101	next;
010001000011	t2->word
010001000100	%
0100010001010	line,boolean
0100010001011	//indicates
0100010001100	(compareString(temp2->word,word)
0100010001101	//build
010001000111	inserted
0100010010000	str1[i];
0100010010001	99)
0100010010010	dirent
0100010010011	str1+str2;
0100010010100	str2[i])
0100010010101	(ptr->left)
0100010010110	encode
0100010010111	<=
01000100110	codebook,
0100010011100	hashcodeWord(char*);//computes
0100010011101	(char*)malloc((length-start)*sizeof(char)
0100010011110	(char*)malloc(index
0100010011111	heapArr[heapCount].freq
0100010100000	substring(fileText,start,end);
0100010100001	open(fileName,
010001010001	strlen(str2);
0100010100100	//proper
0100010100101	non-null
0100010100110	coding
0100010100111	ordering
010001010100	treeFree(huffmanTree);
0100010101010	arr)
0100010101011	heapArr[small].freq
01000101011	array
0100010110000	codebook\n",temp);
0100010110001	open(newFile,O_WRONLY
0100010110010	successfully
0100010110011	codebook\n");
0100010110100	nothing
0100010110101	(hashNode**)malloc(size
010001011011	success
0100010111000	ptr->freq+=
0100010111001	compressed\n",temp);
0100010111010	ptr->freq;
0100010111011	%d\n",heapArr[i].word,heapArr[i].freq,heapArr[i].isTree);
010001011110	constructHeap()
0100010111110	(ptr->right)
0100010111111	<dirent.h>
010001100000	poll();
0100011000010	comp)
0100011000011	polling
0100011000100	poll()
0100011000101	command
010001100011	compareString("./HuffmanCodebook\0",huffBook)
0100011001000	passed
0100011001001	(heapSize/2)
010001100101	phases
010001100110	combineString(temp,dir->d_name);
0100011001110	output
0100011001111	overwrite
0100011010000	substring(toDecompress,0,(strlen(toDecompress)-7));
0100011010001	//searches
0100011010010	hashSearch(char*
0100011010011	{//1
01000110101	hashcode
0100011011000	produce
0100011011001	program
0100011011010	<stdio.h>
0100011011011	errors
010001101110	parent;
0100011011110	strlen(argv[2])
0100011011111	combineString(fileText,buffer);
0100011100000	(int)str2[i]);//negative
0100011100001	compress(char*,char*);//compresses
0100011100010	printHeap();//prints
0100011100011	0;//amount
0100011100100	//Was
0100011100101	increment
0100011100110	they
0100011100111	index;
0100011101000	aren't
0100011101001	heapArr[heapSize];
0100011101010	(uses
0100011101011	_hashTable{
010001110110	str1,
0100011101110	updates
0100011101111	used,
010001111000	node
010001111001	(codebook
01000111101	tree->left
0100011111000	item1.freq
0100011111001	item2
010001111101	build,
010001111110	item2.tree;
010001111111	buildHuff();
010010000000	fd;
0100100000010	incremented
0100100000011	increments
01001000001	lineDelim
01001000010	100);
010010000110	init
0100100001110	(compareString(temp2->binary,binary)
0100100001111	//all
0100100010000	*dir;
0100100010001	heapArr
010010001001	+=
010010001010	heapInit();
010010001011	treeFree(root);
010010001100	hashSize);
0100100011010	'\0';
0100100011011	(bstSearch(word)
0100100011100	open(output,O_WRONLY
0100100011101	open(toCompress,
0100100011110	word;//word
0100100011111	hashInsert(char*,char*,boolean);//inserts
0100100100000	{//swaps
0100100100001	freq
0100100100010	until
0100100100011	update
0100100100100	originally
0100100100101	otherwise
0100100100110	tree->freq
0100100100111	free(table);
010010010100	len2
0100100101010	table;//used
0100100101011	but
010010010110	fileText
0100100101110	buildHuff()
0100100101111	item;
0100100110000	poll();//returns
0100100110001	((d
0100100110010	}hashTable;
0100100110011	(strlen(path)
0100100110100	treeFree(Node*
0100100110101	NULL,used
0100100110110	{//non-recursive
0100100110111	freqSet;//indicates
0100100111000	free(toFree);
0100100111001	treeFree(Node*);//frees
0100100111010	tree->word
0100100111011	free(temp2);
010010011110	freq;
0100100111110	,used
0100100111111	argv[1][0]
010010100	given
010010101	in
01001011	0)
010011	if
010100000000	0;//equal
0101000000010	tableFree(int);//frees
0101000000011	BST,
0101000000100	tableInit(int
0101000000101	tableInit(int);//initializes
0101000000110	inputs
0101000000111	insert
0101000001	*
0101000010	represents
0101000011	string
0101000100	hashNode*
0101000101000	toInsert.tree
0101000101001	HuffmanCodebook
0101000101010	to;
0101000101011	toDecompress,char*
01010001011	hashtable
0101000110	heapSize
0101000111	(i
0101001000	binary
0101001001	first
010100101	boolean
010100110	phase
0101001110	>
0101001111	.hcz
0101010000	files
0101010001	#include
010101001	is
01010101	to
01010110	<
01010111	a
010110000	while
01011000100	with
01011000101	(index
01011000110	size;
0101100011100	-1),".hcz\0")
0101100011101	heapCount++;
010110001111	Empty
0101100100	will
010110010100	(temp2)
0101100101010	}hashNode;
0101100101011	accordingly
010110010110	free(temp);
0101100101110	heapInit();//initializes
0101100101111	(compareString(dir->d_name,".")
010110011	all
01011010000	data
01011010001	O_RDONLY);
01011010010	'c')
01011010011	found
0101101010	index
01011010110	(strlen(argv[2])
01011010111	'c'
01011011000	Cannot
01011011001	items
01011011010	end++;
01011011011	printf("Error:
0101101110	2)
01011011110	word)
01011011111	an
01011100000	'd')
01011100001	-1;
01011100010	typedef
01011100011	two
0101110010	end
0101110011000	hashSearch(temp,NULL,true);
0101110011001	(word
010111001101	combineString(holder,buffer);
01011100111	out
01011101000	do
01011101001	code
01011101010	huffmancodebook
01011101011	'b')
01011101100	file\n");
01011101101	fd
0101110111	are
0101111000	moreStuff
01011110010	1);
01011110011	continue;
0101111010	return;
01011110110	lineDelim)
01011110111	huffman
01011111	void
011				
10000	=
100010000	i
1000100010	holder
1000100011	not
100010010	&&
100010011	of
10001010	0;
100010110	return
100010111	Invalid
1000110	==
1000111	the
1001000000	heap
1001000001	decompress
1001000010	NULL)
100100001100	'\t';
100100001101	heap,
100100001110	allows
100100001111	*d;
10010001	char*
10010010	else
100100110	false;
1001001110	Node*
100100111100	compress:
100100111101	4
100100111110	0
100100111111	elements
10010100000	buffer[end]
10010100001	length
100101000100	compress)
100101000101	printf("file
100101000110	DIR
100101000111	is:
10010100100	it
10010100101	tab
1001010011	temp;
10010101000	within
10010101001	strings
10010101010	on
10010101011	(moreStuff)
10010101100	word,
100101011010	//initializes
100101011011	'
100101011100	>=
100101011101	(fd
100101011110	(strlen(argv[1])
100101011111	//inserts
100101100000	}while(readIn
100101100001	'd';
100101100010	result;
100101100011	right;
100101100100	based
100101100101	close(fileParse);
10010110011	current
10010110100	tabs
100101101010	it's
100101101011	it,
100101101100	(compareString(ptr->word,word)
100101101101	binInsert2
100101101110	(strlen(temp)
100101101111	false)
100101110000	nodes
100101110001	frequency
100101110010	you
100101110011	true)
100101110100	left;
100101110101	table->table[index];
10010111011	file,
100101111	||
100110000000	'b';
100110000001	heapify
100110000010	heapArr[small].freq)
100110000011	new
10011000010	left
10011000011	(flag
100110001000	space
100110001001	start;
100110001010	index)
100110001011	bst,
10011000110	recursive
100110001110	through
100110001111	this
10011001000	present
100110010010	(mode
100110010011	(argc
1001100101	word
10011001100	ptr
100110011010	rerun\n");
100110011011	rebuild
10011001110	shorter
10011001111	be
100110100000	combineString(holder,temp);
100110100001	words
100110100010	(ptr
100110100011	//used
100110100100	compute
100110100101	properly
100110100110	which
100110100111	substring(buffer,start,end);
100110101000	right
100110101001	result[j]
10011010101	'-'
100110101100	(first
100110101101	set
100110101110	each
100110101111	returns
10011011000	len
100110110010	holder;
100110110011	huffBook)
10011011010	whether
10011011011	printf("Warning:
100110111000	item2.freq;
100110111001	bytesWritten
100110111010	'\0')
100110111011	'c';
100110111100	bst
100110111101	len;
10011011111	true
100111000000	j
100111000001	fileParse
10011100001	-1
100111000100	Word
100111000101	substring(buffer,start,-1);
100111000110	word;
100111000111	functions
1001110010	build
100111001100	sequence
100111001101	constructHeap();
10011100111	small
100111010000	trying
100111010001	according
100111010010	read(fileParse,buffer,100-readIn);
100111010011	100)
1001110101	compress
100111011	used
100111100	Error:
100111101	printf("Fatal
1001111100	our
1001111101	+
1001111110	or
1001111111	file
1010000	int
1010001000	(buffer[end]
1010001001	start
1010001010	i++)
1010001011	flag
10100011	for
101001	}
101010	{
10101100	!=
101011010000	';
10101101000100	codes,used
10101101000101	open(toDecompress,
10101101000110	opendir(argv[3])))
10101101000111	opendir(path)))
10101101001	spaceDelim
10101101010	readIn
10101101011	-1)
10101101100	(Node*)malloc(sizeof(Node));
10101101101	item
10101101110	tabDelim
10101101111	break;
1010111000	from
10101110010	contents
10101110011	-
10101110100	temp2
10101110101	tree
1010111011	NULL;
101011110	and
101011111	exit(0);
1011000000	codebook
1011000001	i;
1011000010	1;
1011000011	char
1011000100	into
10110001010000	false,
10110001010001	(rootSet
10110001010010	error:
10110001010011	(recursive)
1011000101010	end;
1011000101011	read
1011000101100	string,
10110001011010	5)
10110001011011	directory\n",argv[2]);
10110001011100	<fcntl.h>
10110001011101	end-1
1011000101111	size)
10110001100000	temp->right
10110001100001	//checks
10110001100010	temp->word
10110001100011	invalid
101100011001	line
10110001101000	buildHuff();//builds
10110001101001	//copys
1011000110101	length;
10110001101100	buiuld
10110001101101	//cuts
10110001101110	//function
10110001101111	bytestoWrite)
10110001110	&
1011000111100	2;
1011000111101	created
101100011111	tree->right
10110010000000	compareString(substring(path,(strlen(path)-4),-1),".hcz\0")
10110010000001	printBst(Node*);//prints
1011001000001	starting
1011001000010	'./HuffmanCodebook'\n");
10110010000110	to,
10110010000111	formatted,
101100100010	fd2
1011001000110	buffer[99]
1011001000111	//combines
10110010010000	sizeof(heapItem));
10110010010001	0;//number
10110010010010	properties
10110010010011	compressed;
10110010010100	compress(char*
10110010010101	printf("PRINTING
10110010010110	compress/decompress
10110010010111	printhuffTree(ptr->right,codeArr,index+1,fd);
1011001001100	huffmancode
1011001001101	binary,boolean
10110010011100	str2[i];
10110010011101	perform
10110010011110	path,int
10110010011111	combineString(toCompress,".hcz");
10110010100000	temp->freqSet
10110010100001	isTree;//
10110010100010	temp->left
10110010100011	bstSearch(char*
101100101001	len1;
10110010101000	library
10110010101001	can
10110010101010	//contructs
10110010101011	itself
101100101011	bytesRead
10110010110000	result[i]
10110010110001	1;//first
10110010110010	2
10110010110011	copyString(tWord,heapArr[small].word);
101100101101	nodeCount;
10110010111000	//one
10110010111001	memset(to,'\0',(length+1));
10110010111010	!(ptr->right))
10110010111011	";//used
1011001011110	rootSet
10110010111110	readFile(char*);//reads
10110010111111	readFile(path);
10110011000000	heapArr;//our
10110011000001	heapArr[0]
10110011000010	boolin
10110011000011	inconistencies
101100110001	O_CREAT
10110011001000	argv)
10110011001001	heapArr[index].freq
1011001100101	heapArr[right].freq
1011001100110	codeArr[index]
10110011001110	arr
10110011001111	heapArr[small]
10110011010000	writeTo(int,char*);//writes
10110011010001	warnings)
10110011010010	hashSearch("\t\0",NULL,true);//one
10110011010011	hashSearch("\t\t\0",NULL,true);//two
10110011010100	(char*)malloc((len1+len2)*sizeof(char)
10110011010101	(word[0]
10110011010110	hashSearch(word,binary,comp);
10110011010111	}Node;
1011001101100	open(huffBook,
10110011011010	}heapItem;
10110011011011	hashTable
10110011011100	codebook,boolean
10110011011101	//returns
1011001101111	hashcodeBin(binary);
1011001110000	codeArr
10110011100010	arr,int
10110011100011	heapArr[small].freq;
10110011100100	readHuff(int,boolean);//reads
10110011100101	converts
10110011100110	(Fatal,
10110011100111	copyString(char*,char*);//copies
10110011101000	heapArr[parent].freq
10110011101001	heapArr[parent];
10110011101010	heapArr[index].word
10110011101011	heapArr[index];
101100111011	store
10110011110000	hashcodeBin(char*
10110011110001	hashcodeBin(char*);//computes
10110011110010	hashtable,
10110011110011	also
10110011110100	{//decompress
10110011110101	type
10110011110110	after
10110011110111	hashTable*
101100111110	readIn+=
10110011111100	writeTo(fd,"\n\0");
10110011111101	(toFree
10110011111110	from[i];
10110011111111	value
10110100000	flags
1011010000100	(len1
10110100001010	copyString(root->word,word);
10110100001011	results
1011010000110	copyString(t1->word,item1.word);
10110100001110	recursively
10110100001111	copyString(heapArr[heapCount].word,ptr->word);
10110100010000	project,
10110100010001	0}boolean;
1011010001001	1));
1011010001010	compressing
1011010001011	purposes
10110100011	|
1011010010000	(code
1011010010001	heapArr[left].freq
1011010010010	copyString(t2->word,item2.word);
10110100100110	readFile(temp);
10110100100111	(item2.isTree)
1011010010100	t1;
10110100101010	heapArr[small].word
10110100101011	arr;
1011010010110	root
1011010010111	(len2
10110100110000	substring(char*
10110100110001	substring(char*,int,int);
1011010011001	ptr->left;
10110100110100	storeHuff(holder,compBool);
10110100110101	prev->right
1011010011011	directory\n");
1011010011100	(binInsert
10110100111010	(compareString(word,"\t\t\0")
10110100111011	item)
10110100111100	listDirectories(argv[3],1,argv[4]);
10110100111101	listDirectories(argv[3],2,argv[4]);
1011010011111	(small
1011010100000	t2;
1011010100001	close(fd);
1011010100010	(fd1
10110101000110	long
10110101000111	character)
10110101001000	root->right
10110101001001	readHuff(codebook,false);
10110101001010	start,
10110101001011	4),
10110101001100	copyString(char*
10110101001101	readdir(d))
10110101001110	converting
10110101001111	readHuff(int
10110101010000	table->size
10110101010001	table->table
10110101010010	fd)
10110101010011	(arr[i]
10110101010100	//helper
10110101010101	calls
10110101010110	<sys/types.h>
10110101010111	false;//indicates
10110101011000	BST
10110101011001	fileName)
10110101011010	table->table[i]
10110101011011	(start
10110101011100	fd,char*
10110101011101	table,
10110101011110	temp);
10110101011111	temp->freq
1011010110000	terminator
10110101100010	pos
10110101100011	compBool)
101101011001	status;
10110101101000	newFile
10110101101001	//printf("folder:
10110101101010	name,
10110101101011	closedir(d);
1011010110110	cannot
1011010110111	lineDelim))
10110101110000	substring(line,end+1,-1);
10110101110001	open(argv[4],O_RDONLY);
10110101110010	able
10110101110011	hashSearch(holder,NULL,true);
1011010111010	'R'
10110101110110	hashSearch(NULL,temp,false);
10110101110111	'\t')
10110101111	status
10110110000000	here
10110110000001	binInsert2;
1011011000001	//If
1011011000010	huffmantree
10110110000110	toInsert->word
10110110000111	./\n\n");
10110110001	heapItem
10110110010000	makes
10110110010001	//need
10110110010010	together
10110110010011	heapSize;
10110110010100	tWord;
10110110010101	main(int
10110110010110	track
10110110010111	avoid
10110110011000	heapify2(int);//the
10110110011001	heapify2(small);
1011011001101	Flags\n");
10110110011100	listDirectories(temp,mode,huffBook);
10110110011101	char**
10110110011110	heapify(int
10110110011111	./\n");
1011011010	true;
10110110110000	toInsert.isTree
10110110110001	heapify2(0);
10110110110010	heapify(small);
10110110110011	between
101101101101	i)
10110110111000	indexed
10110110111001	indicates
10110110111010	bstInsert(char*
10110110111011	initializing
10110110111100	tableFree(int
10110110111101	just
1011011011111	bstNode*
1011011100000	readFile()
1011011100001	see
10110111000100	table->table[i];
10110111000101	lexographically
10110111000110	//temporary,
10110111000111	combineString(char*
10110111001000	strlen(fileText);
10110111001001	'-')
10110111001010	strlen(from);
10110111001011	%d,
10110111001100	strlen(line);
10110111001101	"
1011011100111	(heapSize
1011011101000	binInsert
1011011101001	free(heapArr);
1011011101010	print
10110111010110	positive
10110111010111	presents
10110111011000	(buffer[99]
10110111011001	unless
1011011101101	%s\n",dir->d_name);
10110111011100	combineString(char*,char*);
10110111011101	ourselves
1011011101111	outputs
1011011110	temp
10110111110000	writeTo(fd,"\t\0");
10110111110001	go
10110111110010	writeTo(int
10110111110011	way
1011011111010	writeTo(compressed,binInsert);
1011011111011	(used
10110111111000	length)
10110111111001	call
10110111111010	index,int
10110111111011	bstInsert("\t\0");//one
1011011111110	codebook;
1011011111111	only
1011100000000	strlen(word);
1011100000001	end+1;
1011100000010	(compareString(substring(temp,(strlen(temp)-4),-1),".hcz\0")
10111000000110	toCompress,char*
10111000000111	binary;//binary
10111000001000	bstInsert("\t\t\t\0");//three
10111000001001	initializeHuff();//initializes
10111000001010	//and
10111000001011	bstInsert("\t\t\0");//two
101110000011	flags\n");
101110000100	int*
1011100001010	nonrecursive
1011100001011	t1->freq
101110000110	table
1011100001110	prev
10111000011110	(holder
10111000011111	//writes
10111000100	argv[1][1]
10111000101	struct
10111000110000	strlen(binary);
10111000110001	end)
10111000110010	empty
10111000110011	string:
1011100011010	codeWord;
10111000110110	,
10111000110111	arguments\n");
101110001110	'R')
1011100011110	tree;
1011100011111	hashSize
10111001000000	check
10111001000001	memset(result,'\0',(end-start
1011100100001	t1->right
10111001000100	memset(result,'\0',(len1+len2+1));
10111001000101	memset(result,'\0',(length-start
1011100100011	t2->freqSet
1011100100100	up
1011100100101	heapArr[index]
10111001001100	read:
10111001001101	readFile(char*
1011100100111	99
101110010100	temp2->next;
1011100101010	t1->freqSet
10111001010110	//printf("temp
10111001010111	node,
1011100101100	t1->left
1011100101101	(!(d
1011100101110	sum;
10111001011110	nodeCount
10111001011111	(hashNode*)malloc(sizeof(hashNode));
101110011000	tableFree(1000);
1011100110010	item1.freq;
1011100110011	item1.tree;
10111001101000	(binary[0]
10111001101001	free(binary);
10111001101010	HEAP\n");
10111001101011	free(fileText);
1011100110110	smallest
1011100110111	4)
10111001110000	sizeof(int));
10111001110001	(int*)malloc(nodeCount
1011100111001	compressed
1011100111010	heapSize--;
1011100111011	free(codeArr);
1011100111100	len1
1011100111101	len1)
101110011111	%s,
10111010000000	'0';
10111010000001	(item1.isTree)
1011101000001	(2
10111010000100	tFreq
10111010000101	close(codebook);
10111010000110	listDirectories(char*
10111010000111	listDirectories(char*,int,char*);//lists
10111010001000	arrInit(int*);//initializes
10111010001001	heapInsert(heapItem
10111010001010	heapArr[small];
10111010001011	heapCount
101110100011	//computes
1011101001000	len2;
1011101001001	//frees
101110100101	j++;
1011101001100	(left
10111010011010	(line[end]
10111010011011	2;//second
1011101001110	(compress
1011101001111	built
101110101000	1)
10111010100100	<limits.h>
10111010100101	ensure
10111010100110	<math.h>
10111010100111	enum
10111010101000	tFreq;
10111010101001	tWord
1011101010101	tabDelim)
101110101011	O_TRUNC,00600);
1011101011000	respective
10111010110010	copyString(toInsert->binary,binary);
10111010110011	copyString(toInsert->word,word);
1011101011010	sizeof(char)
10111010110110	root->word
10111010110111	root;//our
10111010111	(status
1011101100000	nodeCount++;
10111011000010	heapArr[index].freq)
10111011000011	heapArr[index].freq;
10111011000100	inserts
10111011000101	bstInsert(temp);
10111011000110	//builds
10111011000111	bstInsert(holder);
10111011001000	files\n",temp);
10111011001001	temp2->word;
10111011001010	files,
10111011001011	(stores
10111011001100	followed
10111011001101	through)
1011101100111	toInsert
101110110100	hash
1011101101010	str2)
10111011010110	1)/2;
10111011010111	read(codebook,buffer,100-readIn);
10111011011000	1,
10111011011001	continues
10111011011010	copyString(heapArr[index].word,tWord);
10111011011011	copyString(heapArr[small].word,heapArr[index].word);
1011101101110	arrInit(codeArr);
10111011011110	}while
10111011011111	%s\n",
10111011100000	printArr(int*,int);//allows
10111011100001	printBst(Node*
1011101110001	printBst(root);
10111011100100	Directory\n");
10111011100101	them
10111011100110	statements
10111011100111	compareString(substring(temp,(strlen(temp)-4),-1),".hcz\0")
10111011101000	compareString(char*,char*);//compares
10111011101001	prev;
10111011101010	ptr)
10111011101011	(item1.isTree
1011101110110	directory
1011101110111	0);
10111011110000	extension
10111011110001	<sys/stat.h>
10111011110010	sure
10111011110011	expected
1011101111010	t2->right
10111011110110	(right
10111011110111	<string.h>
10111011111000	compareString(dir->d_name,"..")
10111011111001	printArr(codeArr,index);
10111011111010	str,
10111011111011	compareString(char*
10111011111100	free(newFile);
10111011111101	free(tWord);
10111011111110	printArr(int*
10111011111111	compareString(substring(argv[2],(strlen(argv[2])
1011110000000	'd'))
1011110000001	len2)
10111100000100	substring
10111100000101	opendir(argv[2])))
10111100000110	//size
10111100000111	codes
1011110000100	testing
1011110000101	their
101111000011	we
10111100010000	toInsert->binary
10111100010001	toInsert->next
10111100010010	storeHuff(temp,compBool);
10111100010011	prev->left
1011110001010	(success
1011110001011	frequencies
1011110001100	O_WRONLY
10111100011010	(temp
10111100011011	from)
10111100011100	writeTo(fd,codeWord);
10111100011101	String
10111100011110	writeTo(decompressed,"\t\0");
10111100011111	hashNode**
10111100100000	free(holder);
10111100100001	toInsert;
1011110010001	printhuffTree(heapArr[0].tree,codeArr,0,fd);
101111001001	us
101111001010	'\n';
10111100101100	writeTo(decompressed,"
10111100101101	_hashNode*
10111100101110	writeTo(compressed,binInsert2);
10111100101111	hashInsert\n");
101111001100	open(argv[3],O_RDONLY);
10111100110100	codeWord[index]
10111100110101	not,
10111100110110	heapArr[heapCount].word
10111100110111	heapArr[heapSize-1];
101111001110	one
1011110011110	open(argv[2],O_RDONLY);
1011110011111	hcz
1011110100000	vals
1011110100001	function
10111101000100	{//compress
10111101000101	hashSearch(char*,char*,boolean);//searches
10111101000110	(char*)malloc((end-start)*sizeof(char)
10111101000111	(will
1011110100100	fd1
10111101001010	initially
10111101001011	bstInsert(char*);//inserts
10111101001100	substring(line,start,end);
10111101001101	codebook\n",path);
10111101001110	(!(ptr->left)
10111101001111	(hashTable*)malloc(sizeof(hashTable));
10111101010000	end-2)
10111101010001	(readIn
10111101010010	strlen(str);
10111101010011	strlen(temp)
10111101010100	codeArr,int
10111101010101	no
10111101010110	heapArr[i]
10111101010111	argc,
1011110101100	codeWord[i]
10111101011010	heapArr[i].freq
10111101011011	heapArr[i].freq)
1011110101110	values
1011110101111	was
10111101100000	5
10111101100001	storeHuff(),
1011110110001	str[i];
10111101100100	to[i]
10111101100101	heapify(i);
10111101100110	tree->freqSet
10111101100111	heapItem*
1011110110100	close(fd1);
10111101101010	%s\n",output);
10111101101011	(compareString(ptr->word,
10111101101100	//turns
10111101101101	own
10111101101110	free(word);
10111101101111	treeFree(toFree->right);
10111101110000	argv[2];
10111101110001	heapArr[parent]
10111101110010	"tree\0";
10111101110011	%s\n",newFile);
1011110111010	null
10111101110110	heapInsert(heapItem);//inserts
10111101110111	arr[i]
10111101111	(argv[1][1]
1011111000000	parent
1011111000001	greater
10111110000100	heapArr[i].isTree
10111110000101	heapArr[i];
10111110000110	'b'
10111110000111	(char*)malloc(length
10111110001000	"";
10111110001001	(non-inclusive
1011111000101	(argv[1][0]
101111100011	memset(buffer,'\0',101);
10111110010000	decompress(char*,char*);//decompresses
10111110010001	decompress(temp,huffBook);
10111110010010	seperately),
10111110010011	3
1011111001010	should
10111110010110	root->freq
10111110010111	root->freqSet
10111110011000	'1';
10111110011001	copyString(temp->word,word);
10111110011010	compressed\n");
10111110011011	ptr,int*
10111110011100	DT_DIR)
10111110011101	flag;
10111110011110	(binInsert2
10111110011111	(str1[i]
10111110100000	stuff
10111110100001	(heapItem*)malloc(nodeCount
10111110100010	hashElements
10111110100011	\0");
10111110100100	//stores
10111110100101	codeword
10111110100110	write(fd,word,bytestoWrite-bytesWritten);
10111110100111	(bytesWritten
10111110101000	writeTo(fd,ptr->word);
10111110101001	global
10111110101010	_hashNode
10111110101011	hashInsert(word,binary,comp);
1011111010110	heapArr[0];
1011111010111	another
10111110110	(
1011111011100	-b
10111110111010	heapInsert(toInsert);
10111110111011	-1;//not
10111110111100	printhuffTree(ptr->left,codeArr,index+1,fd);
10111110111101	((int)str1[i]
10111110111110	0;//keeps
10111110111111	printhuffTree(Node*
10111111000000	toInsert.freq
10111111000001	heapify2(int
10111111000010	toInsert.word
10111111000011	heapify(int);
10111111000100	decompress)
10111111000101	decompress:
10111111000110	root->left
10111111000111	readHuff(codebook,true);
1011111100100	//parses
10111111001010	heapInit()
10111111001011	arrInit(int*
1011111100110	combined
10111111001110	free(toFree->word);
10111111001111	treeFree(toFree->left);
10111111010000	exists)
10111111010001	<stdlib.h>
1011111101001	(argv[2][1]
1011111101010	ptr->right;
1011111101011	ptr;
10111111011000	printBst(ptr->right);
10111111011001	printHeap()
1011111101101	printf("location
10111111011100	compress(argv[2],argv[3]);
10111111011101	printf("%s:
10111111011110	table->table[index]
10111111011111	table;
1011111110000	decompressed
10111111100010	decompress(char*
10111111100011	sizeof(hashNode*));
101111111001	argv[2][1]
1011111110100	false
1011111110101	t2
10111111101100	decompressed;
10111111101101	directories
10111111101110	storeHuff(char*
10111111101111	storeHuff(char*,boolean);//stores
10111111110	(end
10111111111000	decompress(argv[2],argv[3]);
10111111111001	3)
1011111111101	str1
1011111111110	%s
1011111111111	root;
11			
