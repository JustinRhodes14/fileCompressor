000000000000	(used
000000000001	parent;
0000000000100	converting
0000000000101	paranoia.
0000000000110	over.
0000000000111	overactive
0000000001000	converts
0000000001001	parents,
0000000001010	HuffmanCodebook
0000000001011	copyString(char*
000000000110	year.
0000000001110	yet.
0000000001111	(strlen(path)
0000000010000	check
0000000010001	(readIn
0000000010010	<math.h>
0000000010011	character)
0000000010100	life.
0000000010101	(recursive)
0000000010110	lexographically
0000000010111	<stdlib.h>
00000000110	store
0000000011100	hashElements
0000000011101	aren't
0000000011110	arguments\n");
0000000011111	usage
0000000100000	kinds
0000000100001	chalk-dust
0000000100010	read:
0000000100011	readFile(char*
00000001001	result
00000001010	is:
000000010110	inserted
0000000101110	name
0000000101111	combineString(toCompress,".hcz");
0000000110000	hashTable
0000000110001	(!(ptr->left)
000000011001	!n
00000001101	hashcode
000000011100	weeks
000000011101	node
0000000111100	recording
0000000111101	directory\n",argv[2]);
0000000111110	really
0000000111111	reasons.
000000100000	need
000000100001	scary
000000100010	always
000000100011	(codebook
0000001001000	breaks.
0000001001001	breath,
0000001001010	-1),".hcz\0")
0000001001011	root->freq
000000100110	printhuffTree(heapArr[0].tree,codeArr,0,fd);
0000001001110	awake.
0000001001111	heapArr[heapSize-1];
0000001010000	understand
0000001010001	dead.
0000001010010	car,
0000001010011	99)
0000001010100	'1';
0000001010101	(I
0000001010110	isn't
0000001010111	by
000000101100	2;
0000001011010	arrInit(int*);//initializes
0000001011011	haunted.
0000001011100	{//non-recursive
0000001011101	(binInsert2
0000001011110	now
0000001011111	now.
0000001100000	visit
0000001100001	printBst(ptr->right);
0000001100010	mode,
0000001100011	And
0000001100100	printArr(int*,int);//allows
0000001100101	printBst(Node*
0000001100110	couple
0000001100111	printBst(Node*);//prints
0000001101000	copyString(toInsert->word,word);
0000001101001	positive
000000110101	values
0000001101100	wasn't
0000001101101	prev->left
0000001101110	wakes
0000001101111	country.
00000011100	readIn+=
000000111010	cannot
0000001110110	item1.freq
0000001110111	5
0000001111000	opendir(argv[3])))
0000001111001	opendir(path)))
000000111101	writeTo(compressed,binInsert);
00000011111	'\n';
000001000000	codeArr
000001000001	ptr->left;
0000010000100	<sys/stat.h>
0000010000101	listDirectories(argv[3],0,NULL);
000001000011	ptr->right;
00000100010	(argv[2][0]
000001000110	purposes
0000010001110	listDirectories(argv[3],2,argv[4]);
0000010001111	listDirectories(char*
0000010010000	bytestoWrite)
0000010010001	item1
000001001001	item2.tree;
000001001010	end;
0000010010110	heapArr[parent];
0000010010111	(holder
0000010011000	(hashNode*)malloc(sizeof(hashNode));
0000010011001	hashSearch(char*
0000010011010	heapSize;
0000010011011	0;//keeps
000001001110	heapSize--;
0000010011110	binInsert2;
0000010011111	heapItem*
0000010100000	1)/2;
0000010100001	broken
0000010100010	heapInit()
0000010100011	heapInit();//initializes
0000010100100	heapArr[i]
0000010100101	wrong
0000010100110	heapArr[small].freq
0000010100111	heapArr[small].freq;
0000010101000	rest
0000010101001	rested
0000010101010	until
0000010101011	dead
0000010101100	Directory\n");
0000010101101	nurse
000001010111	old
0000010110000	tableInit(int);//initializes
0000010110001	fd,char*
0000010110010	string:
0000010110011	strlen(argv[2])
0000010110100	writeTo(decompressed,word);
0000010110101	(bstSearch(word)
000001011011	as
00000101110	O_TRUNC,00600);
0000010111100	guess
0000010111101	treeFree(Node*
0000010111110	tree->freq
0000010111111	//otherwise,
0000011000000	fall
0000011000001	stir.
0000011000010	extension
0000011000011	eyes).
00000110001	make
0000011001000	results
0000011001001	%s\n",newFile);
000001100101	down
0000011001100	toInsert->word
0000011001101	empty
0000011001110	roar
0000011001111	room
0000011010000	hashSearch(temp,NULL,true);
0000011010001	//returns
000001101001	//The
000001101010	null
0000011010110	DT_DIR)
0000011010111	compareString(substring(temp,(strlen(temp)-4),-1),".hcz\0")
0000011011000	still,
0000011011001	Two
0000011011010	stop
0000011011011	stop.
000001101110	printf("location
0000011011110	things:
0000011011111	especially
0000011100000	(stores
0000011100001	BST
0000011100010	toInsert.word
0000011100011	scratching
0000011100100	ensure
0000011100101	slightest
000001110011	even
000001110100	die
0000011101010	kind
0000011101011	<=
0000011101100	}hashNode;
0000011101101	newLine
000001110111	(heapSize
0000011110000	tired
0000011110001	endure
0000011110010	heapArr[index].freq)
0000011110011	'-')
000001111010	never
000001111011	(binInsert
000001111100	testing
0000011111010	that's
0000011111011	starving
000001111110	@n
0000011111110	start,
0000011111111	started
0000100000000	hello
0000100000001	(int*)malloc(nodeCount
000010000001	huffmancode
000010000010	huffmantree
0000100000110	heapInsert(heapItem
0000100000111	0;//amount
000010000100	hashSize
0000100001010	wake
0000100001011	hashSearch(char*,char*,boolean);//searches
0000100001100	open(argv[4],O_RDONLY);
0000100001101	open(fileName,
000010000111	at
0000100010000	them
0000100010001	exists)
0000100010010	ever.
0000100010011	sounds.
000010001010	freq;
0000100010110	these
0000100010111	%s\n",output);
0000100011000	sizeof(heapItem));
0000100011001	sizeof(int));
0000100011010	./\n\n");
0000100011011	Steinbeck,
000010001110	--
0000100011110	bytestoWrite
0000100011111	item)
000010010000	+=
0000100100010	understands
0000100100011	Mrs.
0000100100100	tree->freqSet
0000100100101	remembering
0000100100110	dirent
0000100100111	red
000010010100	swag
000010010101	t1
000010010110	length;
000010010111	t1->left
000010011000	lesser,
0000100110010	_heapItem
0000100110011	successfully
000010011010	t2
000010011011	t2->freq
0000100111000	substring(fileText,start,end);
0000100111001	substring(line,end+1,-1);
0000100111010	files,
0000100111011	able
0000100111100	substring(line,start,end);
0000100111101	substring(toDecompress,0,(strlen(toDecompress)-7));
0000100111110	_hashTable{
0000100111111	fileName)
00001010000	already
00001010001	long
0000101001	(status
0000101010000	index;++i)
0000101010001	indexed
0000101010010	indicates
0000101010011	buildHuff()
000010101010	combineString(path,"/");
0000101010110	combineString(char*,char*);
0000101010111	combineString(fileText,buffer);
0000101011000	(non-inclusive
0000101011001	itself
000010101101	99
0000101011100	(line[end]
0000101011101	3)
0000101011110	insert
0000101011111	3
00001011000	can't
0000101100100	readHuff(codebook,true);
0000101100101	readHuff(int
000010110011	item1.freq;
000010110100	item1.tree;
0000101101010	issues
0000101101011	4),
0000101101100	case
0000101101101	journals,
0000101101110	chalky
0000101101111	lack).
0000101110000	me.
0000101110001	means
000010111001	//If
0000101110100	require
0000101110101	documenting
0000101110110	Now,
0000101110111	directories
000010111100	directory\n");
000010111101	treeFree(huffmanTree);
0000101111100	desk
0000101111101	readFile(temp);
000010111111	//parses
0000110000000	decompress(temp,huffBook);
0000110000001	putting
0000110000010	leap
0000110000011	learned,
000011000010	len1
000011000011	len1)
0000110001000	codebook\n",path);
0000110001001	memset(result,'\0',(length-start
0000110001010	menacing,
0000110001011	mentally,
000011000110	starting
0000110001110	arr)
0000110001111	hashTable*
0000110010000	Can
0000110010001	negative
0000110010010	}heapItem;
0000110010011	comes
00001100101	come
000011001100	another
0000110011010	call
0000110011011	calls
000011001110	kept
0000110011110	cares
0000110011111	journals
00001101	0)
0000111	a
0001000	for
0001001	and
000101000	into
000101001	given
0001010100	could
0001010101	represents
0001010110	string
0001010111	#include
0001011000	most
0001011001	*
000101101	phase
000101110000	created
0001011100010	coding
0001011100011	mode,char*
00010111001	data
0001011101	.hcz
0001011110	own
0001011111	heapSize
0001100	to
0001101000	binary
0001101001	(i
0001101010	hashNode*
0001101011	>
0001101100	two
0001101101	files
000110111	start
000111	the
001				
010000	if
010001000	boolean
010001001	our
01000101	<
010001100	while
0100011010	we
01000110110	Cannot
01000110111	printf("Error:
01000111000	just
01000111001	found
01000111010	fd
01000111011	'c')
01000111100	typedef
01000111101	trying
0100011111	index
01001000000	size;
01001000001	'b')
0100100001	2)
01001000100	O_RDONLY);
01001000101	huffman
0100100011	moreStuff
0100100100	first
01001001010	word)
01001001011	lineDelim)
01001001100	hashtable
01001001101	code
01001001110	next
01001001111	(strlen(argv[2])
01001010000	file\n");
01001010001	'd')
0100101001	return;
01001010100	an
01001010101	items
01001010110	words
01001010111	continue;
0100101100000	much,
0100101100001	must
010010110001	word;
01001011001	they
01001011010	end++;
01001011011	-1;
010010111	or
0100110000000	temp2->word;
0100110000001	ago
010011000001	like
010011000010	flag.
0100110000110	ago,
0100110000111	free(toFree);
0100110001	me
01001100100	who
01001100101	mention
0100110011	about
010011010	be
0100110110	holder
01001101110	1);
01001101111	huffmancodebook
01001110	void
01001111	in
01010	=
01011000	of
01011001000	(index
01011001001	should
01011001010	'c'
010110010110	nodes
010110010111	based
0101100110	decompress
0101100111	-
010110100	return
010110101	i
01011011	0;
0101110000	heap
0101110001	so
010111001	Invalid
010111010	&&
0101110110	NULL)
0101110111	left
0101111	==
01100000	char*
0110000100	end
011000010100	(compareString(ptr->word,word)
011000010101	frequency
011000010110	something
011000010111	some
011000011	false;
01100010	else
011000110000	preinstalled.
011000110001	(temp2)
01100011001	new
011000110100	constructHeap();
011000110101	without
011000110110	morning
011000110111	combineString(holder,temp);
011000111000	president
011000111001	*d;
011000111010	wholesome
011000111011	opinion.
011000111100	(strlen(argv[1])
011000111101	'\0')
011000111110	country,
011000111111	no
01100100000	tabs
011001000010	fileParse
011001000011	(ptr
011001000100	IQ
011001000101	//used
01100100011	true
01100100100	ban
01100100101	(flag
01100100110	you
01100100111	present
011001010000	elements
011001010001	efficient.
01100101001	shorter
011001010100	Reddit
011001010101	bst,
01100101011	file,
01100101100	ideas
011001011010	America
011001011011	progressive
0110010111	temp;
011001100	||
011001101000	it.
011001101001	far
011001101010	result[j]
011001101011	This
01100110110	I've
011001101110	false)
011001101111	stories
01100111000	small
01100111001	every
0110011101	build
011001111000	superpower.
011001111001	surpass
011001111010	higher
011001111011	emojis
011001111100	tok
011001111101	set
011001111110	(fd
011001111111	her
011010000000	direction.
011010000001	Minecraft
01101000001	(moreStuff)
011010000100	left;
011010000101	according
011010000110	substring(buffer,start,end);
011010000111	j
011010001000	index)
011010001001	result;
01101000101	easily
011010001100	it's
011010001101	bytesWritten
011010001110	PewDiePie
011010001111	rerun\n");
01101001000	think
011010010010	>=
011010010011	properly
011010010100	rebuild
011010010101	journal
011010010110	tik
011010010111	train
01101001100	-1
011010011010	read(fileParse,buffer,100-readIn);
011010011011	len;
011010011100	table->table[index];
011010011101	'c';
011010011110	feeling
011010011111	its
011010100000	allows
011010100001	//initializes
011010100010	holder;
011010100011	huffBook)
011010100100	sold
011010100101	society
011010100110	right;
011010100111	time
01101010100	out
011010101010	compute
011010101011	computer
01101010110	which
01101010111	whether
01101011000	strings
011010110010	too.
011010110011	each
011010110100	Those
011010110101	item2.freq;
011010110110	Word
011010110111	it:
011010111000	functions
011010111001	'b';
011010111010	seen
011010111011	bst
011010111100	(mode
011010111101	'
01101011111	good
011011000000	The
011011000001	space
011011000010	don't
011011000011	start;
011011000100	'\t';
011011000101	America.
01101100011	word,
011011001000	only
011011001001	compress:
01101100101	has
01101100110	their
011011001110	(strlen(temp)
011011001111	Empty
011011010000	';
011011010001	true)
01101101001	buffer[end]
011011010100	writes
011011010101	compress)
01101101011	length
011011011000	fortnite,
011011011001	fear
011011011010	everyone
011011011011	too!
011011011100	past
011011011101	heap,
01101101111	'-'
011011100000	when
011011100001	posts
01101110001	len
011011100100	}while(readIn
011011100101	night
011011100110	countries.
011011100111	DIR
011011101000	heapify
011011101001	100)
011011101010	sequence
011011101011	say
011011101100	0
011011101101	bed
011011101110	heapArr[small].freq)
011011101111	'd';
011011110000	close(fileParse);
011011110001	look
011011110010	combineString(holder,buffer);
011011110011	(first
01101111010	printf("Warning:
01101111011	much
01101111100	recursive
011011111010	(argc
011011111011	substring(buffer,start,-1);
0110111111	Node*
011100000000	ideas,
011100000001	am
011100000010	free(temp);
011100000011	4
011100000100	still
011100000101	government,
011100000110	returns
011100000111	Think
0111000010	word
01110000110	tab
011100001110	certain
011100001111	know
01110001000	writing
01110001001	ptr
011100010100	countries
0111000101010	natural
01110001010110	name.
01110001010111	name\n");
01110001011	current
01110001100	within
01110001101	but
011100011100	printf("file
011100011101	Keanu
011100011110	//inserts
011100011111	binInsert2
011100100	would
011100101	used
011100110	Error:
0111001110	compress
0111001111	(buffer[end]
0111010000	will
0111010001	+
011101001	printf("Fatal
0111010100	file
0111010101	flag
0111010110	i++)
0111010111	was
0111011	int
011110	}
011111	{
10000000	!=
100000010	have
10000001100	up
10000001101	one
1000000111	are
10000010000	many
10000010001	more
1000001001	on
10000010100	tabDelim
10000010101	readIn
10000010110	break;
10000010111	spaceDelim
10000011000	But
10000011001	It
10000011010	(Node*)malloc(sizeof(Node));
10000011011	contents
10000011100	item
10000011101	tree
10000011110	-1)
10000011111	do
100001000	all
10000100100	than
10000100101	temp2
1000010011	that
100001010	exit(0);
100001011	is
10000110	I
1000011100	1;
1000011101	this
1000011110	char
1000011111	with
1000100000	it
1000100001	i;
1000100010	codebook
1000100011	my
1000100100	NULL;
1000100101000	because
1000100101001	Creek
10001001010100	compBool)
10001001010101	node,
10001001010110	next;
10001001010111	Could
1000100101100	name,
10001001011010	toInsert.tree
10001001011011	-1;//not
10001001011100	Ryan?
10001001011101	emotionally
10001001011110	Ryan.
10001001011111	scared
1000100110000	literal
1000100110001	fd;
10001001100100	polling
10001001100101	populated
10001001100110	poll()
10001001100111	copyString(tWord,heapArr[small].word);
100010011010	it,
10001001101100	allowed
10001001101101	through)
10001001101110	frets.
10001001101111	thought:
1000100111000	str[i];
10001001110010	temp->right
10001001110011	storeHuff(temp,compBool);
10001001110100	//need
10001001110101	to[i]
10001001110110	favorite
10001001110111	str2[i])
1000100111100	phases
10001001111010	I'll
10001001111011	picture
1000100111110	copyString(t2->word,item2.word);
1000100111111	poll();
1000101000000	%s\n",dir->d_name);
10001010000010	codes
10001010000011	might
10001010000100	{//decompress
10001010000101	compareString(char*,char*);//compares
10001010000110	{//swaps
10001010000111	nodeCount
10001010001000	temp->word
10001010001001	storeHuff(holder,compBool);
1000101000101	(compareString(substring(temp,(strlen(temp)-4),-1),".hcz\0")
100010100011	open(argv[3],O_RDONLY);
100010100100	len1;
10001010010100	find
10001010010101	find,
10001010010110	tFreq
10001010010111	(compareString(word,"\t\0")
10001010011000	then.
10001010011001	stalking
10001010011010	there
10001010011011	spent.
100010100111	what
10001010100000	happened.
10001010100001	type
10001010100010	am.
10001010100011	gotten
1000101010010	(fd1
10001010100110	recursively
10001010100111	(char*)malloc(length
10001010101000	expected
10001010101001	state
10001010101010	//Was
10001010101011	Usually
10001010101100	storeHuff(),
10001010101101	storeHuff(char*
10001010101110	sound
10001010101111	"tree\0";
10001010110000	<string.h>
10001010110001	line,boolean
10001010110010	take
10001010110011	fd)
10001010110100	copyString(heapArr[small].word,heapArr[index].word);
10001010110101	copyString(root->word,word);
10001010110110	varsity
10001010110111	printHeap();//prints
10001010111000	sneak
10001010111001	errors
1000101011101	those
1000101011110	smell
10001010111110	slept
10001010111111	(compareString(ptr->word,
1000101100	true;
10001011010000	Sarah
10001011010001	encode
10001011010010	So
10001011010011	end-2)
10001011010100	(start
10001011010101	codebook\n");
10001011010110	codeword
10001011010111	mode
10001011011000	heapArr[heapSize];
10001011011001	//two
10001011011010	wrote
10001011011011	heapArr[i].freq
1000101101110	binInsert
1000101101111	size)
10001011100000	days
10001011100001	project,
10001011100010	urge
10001011100011	dawn,
10001011100100	up,
10001011100101	program
10001011100110	printhuffTree(ptr->right,codeArr,index+1,fd);
10001011100111	prodigy
10001011101000	statements
10001011101001	(compareString(substring(argv[2],(strlen(argv[2])-4),-1),".hcz\0")
10001011101010	expect
10001011101011	starts
10001011101100	unless
10001011101101	properties
1000101110111	My
1000101111000	Reason
1000101111001	root
100010111101	%s,
1000101111100	shaking
1000101111101	-b
10001011111100	toInsert.freq
10001011111101	seems
10001011111110	root->right
10001011111111	root->word
1000110000000	put
1000110000001	read
10001100000100	";//used
10001100000101	(char*)malloc((len1+len2)*sizeof(char)
10001100000110	Last
10001100000111	cut
10001100001000	printhuffTree(Node*
10001100001001	printhuffTree(Node*,int*,int,int);//stores
10001100001010	value
10001100001011	printf("%s:
10001100001100	printf("PRINTING
10001100001101	creation
10001100001110	valid
10001100001111	printf("error
10001100010000	//printf("folder:
10001100010001	answer,
1000110001001	under
1000110001010	//recursive
10001100010110	hashNode**
10001100010111	//reads
10001100011000	great
10001100011001	tree->word
10001100011010	hadn't
10001100011011	hahaha
100011000111	int*
10001100100000	(dir->d_type
10001100100001	//helper
1000110010001	strlen(str1);
100011001001	fd2
10001100101	(argv[1][1]
10001100110	other
100011001110	through
10001100111100	hashcodeBin(char*);//computes
10001100111101	hashcodeWord(char*
10001100111110	//size
10001100111111	arr;
1000110100000	heapArr[index]
10001101000010	{//recursive
10001101000011	compareString(char*
10001101000100	continues
10001101000101	overanalyzes,
1000110100011	compressing
100011010010	flags\n");
100011010011	tree->right
10001101010000	free(temp2);
10001101010001	//function
10001101010010	free(toFree->word);
10001101010011	agrees
10001101010100	sit
10001101010101	./\n");
10001101010110	thing
10001101010111	//indicates
1000110101100	close(fd);
10001101011010	prev->right
10001101011011	In
100011010111	lineDelim
10001101100	used\n");
10001101101000	jump
10001101101001	category
1000110110101	treeFree(root);
100011011011	If
10001101110000	temp2->binary;
10001101110001	free(table);
10001101110010	freqSet;//indicates
10001101110011	alive
10001101110100	tableInit(int
10001101110101	fourteen
10001101110110	torn
10001101110111	//one
100011011110	status;
10001101111100	temp->freq
10001101111101	again.
1000110111111	terminator
1000111000000	(len1
10001110000010	inconistencies
10001110000011	2
10001110000100	bstInsert("\t\t\0");//two
10001110000101	bstInsert("\t\t\t\0");//three
10001110000110	heapify2(0);
10001110000111	board
10001110001	flags
10001110010000	bus
10001110010001	isTree;//
1000111001001	directory
100011100101	Skeleton
10001110011000	tray
10001110011001	dog
1000111001101	go
10001110011100	increments
10001110011101	(Fatal,
1000111001111	(code
10001110100000	table->size
10001110100001	followed
10001110100010	tFreq;
10001110100011	tWord
1000111010010	t1->freqSet
10001110100110	//contructs
10001110100111	adage
10001110101000	match,
10001110101001	may
1000111010101	(!(d
10001110101100	propped
10001110101101	ptr)
1000111010111	ptr;
1000111011000	important
10001110110010	bstInsert(holder);
10001110110011	i--)
10001110110100	(Although
10001110110101	(item2.isTree)
1000111011011	(left
10001110111000	notes
10001110111001	nothing
10001110111010	you.
10001110111011	compareString(substring(path,(strlen(path)-4),-1),".hcz\0")
10001110111100	copyString(char*,char*);//copies
10001110111101	path
1000111011111	open("./HuffmanCodebook",
10001111000000	nurse's
10001111000001	compress(argv[2],argv[3]);
1000111100001	written
1000111100010	%
10001111000110	piano
10001111000111	(will
10001111001000	heapify2(int
10001111001001	heapify2(int);//the
1000111100101	here
1000111100110	1));
10001111001110	0}boolean;
10001111001111	boney
100011110100	'R')
10001111010100	worries
10001111010101	//temporary,
10001111010110	thin.
10001111010111	events
10001111011000	String
10001111011001	error:
10001111011010	slowly
10001111011011	enum
10001111011100	after.
10001111011101	free(fileText);
10001111011110	table->table[i];
10001111011111	stuff
10001111100000	habit
10001111100001	treeFree(toFree->left);
10001111100010	treeFree(Node*);//frees
10001111100011	guys
100011111001	temp2->next;
1000111110100	respective
10001111101010	//printf("temp
10001111101011	uncertain
1000111110110	%s
10001111101110	//build
10001111101111	\0");
10001111110000	day,
10001111110001	produce
10001111110010	NULL,used
10001111110011	decompress)
100011111101	back
10001111111000	copyString(heapArr[index].word,tWord);
10001111111001	perfect.
10001111111010	writing.
10001111111011	'\0';
10001111111100	perform
10001111111101	I'd
1000111111111	copyString(t1->word,item1.word);
1001000000	We
1001000001	temp
1001000010000	heapArr[left].freq
10010000100010	newFile
10010000100011	command
1001000010010	vals
1001000010011	hcz
1001000010100	(success
1001000010101	open(argv[2],O_RDONLY);
10010000101100	off,
10010000101101	compress(char*,char*);//compresses
10010000101110	writer.
10010000101111	compress(temp,huffBook);
1001000011000	t1->freq
10010000110010	free(binary);
10010000110011	tall
100100001101	can
10010000111000	ptr,int*
10010000111001	(char*)malloc((length-start)*sizeof(char)
10010000111010	<stdio.h>
10010000111011	childhood.
1001000011110	readFile()
1001000011111	trying.
10010001000	status
100100010010	array
10010001001100	poll();//returns
10010001001101	copyString(temp->word,word);
1001000100111	hashSize);
10010001010000	Physically,
10010001010001	down.
10010001010010	drive.
10010001010011	dry
10010001010100	compareString(dir->d_name,"..")
10010001010101	normal,
10010001010110	compareString(substring(argv[2],(strlen(argv[2])
10010001010111	not,
10010001011000	item2.isTree)
10010001011001	item;
10010001011010	length)
10010001011011	claw
1001000101110	bstNode*
10010001011110	}Node;
10010001011111	common,
10010001100	heapItem
100100011010	argv[2][1]
100100011011	nodeCount;
10010001110000	printhuffTree(ptr->left,codeArr,index+1,fd);
10010001110001	Like
10010001110010	myself
10010001110011	myself.
10010001110100	memset(to,'\0',(length+1));
10010001110101	codebook\n",temp);
10010001110110	//turns
10010001110111	avoid
10010001111000	listDirectories(argv[3],1,argv[4]);
10010001111001	closedir(d);
10010001111010	making
10010001111011	man
1001000111110	made
10010001111110	codeArr,int
10010001111111	lonely.
10010010000000	known
10010010000001	knows,
10010010000010	ceiling
10010010000011	kill
10010010000100	truth
10010010000101	readFile(char*);//reads
10010010000110	(ptr->left)
10010010000111	<dirent.h>
10010010001000	<fcntl.h>
10010010001001	changed
10010010001010	last
10010010001011	chance
1001001000110	(argv[1][0]
10010010001110	two:
10010010001111	decompress(char*,char*);//decompresses
1001001001000	decompressed
10010010010010	<limits.h>
10010010010011	char**
100100100101	become
10010010011000	tells
10010010011001	Which
10010010011010	str1+str2;
10010010011011	str1[i];
10010010011100	writeTo(int,char*);//writes
10010010011101	one.
10010010011110	(binary[0]
10010010011111	compress(char*
10010010100	struct
1001001010100	'./HuffmanCodebook'\n");
10010010101010	heapify(int
10010010101011	heapify(int);
100100101011	same
10010010110000	binary;//binary
10010010110001	heapify(small);
10010010110010	heapify2(small);
10010010110011	heard.
100100101101	also
100100101110	tree->left
10010010111100	item2
10010010111101	5)
10010010111110	free(word);
10010010111111	freq
10010011000000	bstInsert(temp);
10010011000001	idea
10010011000010	bstNode
10010011000011	imagine
10010011000100	initializing
10010011000101	initially
10010011000110	imagined
10010011000111	bstSearch(char*);//searches
10010011001000	comp)
10010011001001	nights
1001001100101	nonrecursive
1001001100110	Creek.
1001001100111	(strlen(holder)
100100110100	way
1001001101010	O_WRONLY
10010011010110	buildHuff();//builds
10010011010111	inputs
10010011011000	relieved
10010011011001	remain
1001001101101	frequencies
1001001101110	doing
10010011011110	initializeHuff();//initializes
10010011011111	2;//second
1001001110000	str2)
10010011100010	half
10010011100011	truth.
10010011100100	temp->left
10010011100101	false;//indicates
10010011100110	treeFree(toFree->right);
10010011100111	another.
100100111010	codebook,
1001001110110	false
10010011101110	hashSearch("\t\t\t\0",NULL,true);//three
10010011101111	hashSearch(NULL,temp,false);
10010011110000	(word[0]
10010011110001	pretty
10010011110010	well
10010011110011	(bytesWritten
1001001111010	coward
10010011110110	want
10010011110111	printArr(codeArr,index);
10010011111000	pos
10010011111001	position
1001001111101	print
10010011111100	were
10010011111101	'\t')
10010011111110	couldn't
10010011111111	presents
1001010000	I'm
1001010001000	codeArr[index]
1001010001001	free(codeArr);
1001010001010	prev
10010100010110	(word
10010100010111	copyString(toInsert->binary,binary);
1001010001100	parent
10010100011010	open(toDecompress,
10010100011011	opendir(argv[2])))
1001010001110	wonder
10010100011110	words,
10010100011111	over
1001010010	not
10010100110	|
10010100111000	fingers,
10010100111001	//compares
1001010011101	tabDelim)
1001010011110	t2->word
10010100111110	teachers,
10010100111111	//cuts
1001010100000	smallest
10010101000010	basically
10010101000011	heapArr[index].freq
10010101000100	heapSize++;
10010101000101	binary)
1001010100011	toInsert
10010101001000	inserts
10010101001001	buiuld
10010101001010	"
10010101001011	%d\n",heapArr[i].word,heapArr[i].freq,heapArr[i].isTree);
100101010011	i)
1001010101	from
10010101100	argv[1][1]
10010101101000	toDecompress,char*
10010101101001	shoulder.
10010101101010	(compareString(dir->d_name,".")
10010101101011	end)
1001010110110	function
10010101101110	shuffling
10010101101111	simpler
10010101110000	toInsert.isTree
10010101110001	gifted.
10010101110010	together
10010101110011	glancing
10010101110100	hashSearch("\t\t\0",NULL,true);//two
10010101110101	argv[1][0]
10010101110110	argv)
10010101110111	hashSearch("\t\0",NULL,true);//one
10010101111000	then,
10010101111001	everything
10010101111010	soft
10010101111011	That
10010101111100	resting
10010101111101	result[i]
10010101111110	1;//first
10010101111111	bstSearch(char*
10010110000000	writeTo(fd,codeWord);
10010110000001	Even
10010110000010	writeTo(decompressed,"\t\0");
10010110000011	(temp
10010110000100	crawling
10010110000101	printHeap()
10010110000110	vivid
10010110000111	printBst(ptr->left);
10010110001000	heapCount
10010110001001	heapCount++;
1001011000101	0;//equal
1001011000110	4)
10010110001110	ready
10010110001111	real
10010110010000	almost
10010110010001	toCompress,char*
10010110010010	tired.
10010110010011	from[i];
10010110010100	global
10010110010101	too
10010110010110	root;//our
10010110010111	Robert
1001011001100	live
10010110011010	strange
10010110011011	streets,
100101100111	hash
10010110100	country
1001011010100	after
10010110101010	_hashNode
10010110101011	feet,
10010110101100	temp->freqSet
10010110101101	str,
10010110101110	straight
10010110101111	//and
100101101100	had
1001011011010	makes
10010110110110	strong
10010110110111	felt
10010110111000	//all
10010110111001	When
1001011011101	free(heapArr);
1001011011110	codeWord;
1001011011111	str1,
10010111000000	'b'
10010111000001	(char*)malloc(index
10010111000010	temp);
10010111000011	fangs,
1001011100010	fd1
10010111000110	track
10010111000111	train.
10010111001	(
1001011101000	constructHeap()
10010111010010	John
10010111010011	crazy
10010111010100	ordering
10010111010101	originally
10010111010110	worries,
10010111010111	%s\n",
10010111011000	table->table[i]
10010111011001	substring
10010111011010	table->table
10010111011011	_hashNode*
1001011101110	Flags\n");
10010111011110	writeTo(int
10010111011111	one:
10010111100000	memset(result,'\0',(end-start
10010111100001	memset(result,'\0',(len1+len2+1));
10010111100010	used,
10010111100011	*dir;
100101111001	very
1001011110100	codeWord
10010111101010	(right
10010111101011	<sys/types.h>
10010111101100	(str1[i]
10010111101101	Because
10010111101110	printArr(int*
10010111101111	(char*)malloc((end-start)*sizeof(char)
1001011111000	someone
1001011111001	ever
1001011111010	buffer[99]
10010111110110	(heapItem*)malloc(nodeCount
10010111110111	//three
10010111111000	moment.
10010111111001	(arr[i]
10010111111010	moment
10010111111011	combineString(char*
10010111111100	An
10010111111101	codes,used
10010111111110	mind,
10010111111111	miss
1001100000000	combined
10011000000010	root->freqSet
10011000000011	root->left
10011000000100	ride
10011000000101	Practice
1001100000011	root;
1001100000100	codebook;
10011000001010	stare
10011000001011	//Produces
100110000011	memset(buffer,'\0',101);
10011000010	us
1001100001100	spaceDelim)
10011000011010	he
10011000011011	writeTo(compressed,binInsert2);
10011000011100	,used
10011000011101	NULL;//not
10011000011110	truth,
10011000011111	decompressed;
10011000100	(end
10011000101000	been
10011000101001	heapArr[small]
10011000101010	heapArr[parent]
10011000101011	heapArr[parent].freq
10011000101100	decompress(argv[2],argv[3]);
10011000101101	ptr->freq+=
10011000101110	legs
10011000101111	(ptr->right)
1001100011000	built
10011000110010	heapArr[i].isTree
10011000110011	heapArr[i];
10011000110100	heapArr[i].freq)
10011000110101	years
10011000110110	heapArr[heapCount].freq
10011000110111	heapArr[heapCount].word
10011000111000	pages
10011000111001	Hemingway,
10011000111010	part
10011000111011	passed
1001100011110	arrInit(codeArr);
10011000111110	overwrite
10011000111111	conversations
10011001000000	teacher
10011001000001	str2[i];
1001100100001	Write
10011001000100	close(codebook);
10011001000101	library
1001100100011	feel
10011001001000	admitted
10011001001001	formatted,
10011001001010	table->table[index]
10011001001011	table;
1001100100110	len2;
1001100100111	t2->right
10011001010000	age
10011001010001	free(tWord);
10011001010010	free(holder);
10011001010011	free(newFile);
10011001010100	toFree)
10011001010101	alphabetical
10011001010110	get
10011001010111	getting
10011001011000	strlen(temp)
10011001011001	//builds
10011001011010	air
10011001011011	there's
1001100101110	fileText
1001100101111	sum
1001100110000	open(huffBook,
1001100110001	compressed
10011001100100	writer
10011001100101	on.
10011001100110	writers
10011001100111	Ernest
10011001101000	boolin
10011001101001	help
1001100110101	(2
1001100110110	told
1001100110111	hope
10011001110000	readHuff(codebook,false);
10011001110001	didn't
10011001110010	readHuff(int,boolean);//reads
10011001110011	readdir(d))
1001100111010	tree;
1001100111011	do.
10011001111000	enough
10011001111001	skin,
10011001111010	noise
10011001111011	non-null
1001100111110	'R'
1001100111111	close(fd1);
1001101000000	heapInit();
10011010000010	begun
10011010000011	heapArr[small].word
10011010000100	toInsert->next
10011010000101	seperately),
10011010000110	heapArr[small];
10011010000111	better.
1001101000100	build,
10011010001010	increment
10011010001011	incremented
100110100011	100);
10011010010000	hashInsert(char*
10011010010001	hashInsert(char*,char*,boolean);//inserts
1001101001001	str1
10011010010100	write(fd,word,bytestoWrite-bytesWritten);
10011010010101	Frost
1001101001011	heapArr[0];
10011010011	&
1001101010000	close(fd2);
1001101010001	lineDelim))
10011010100100	writeTo(decompressed,"
10011010100101	((argv[1][1]
10011010100110	arr[i]
10011010100111	wouldn't
10011010101000	tableFree(int
10011010101001	strlen(fileText);
1001101010101	(compress
1001101010110	write.
10011010101110	writeTo(fd,"\t\0");
10011010101111	writeTo(fd,ptr->word);
1001101011000	end+1;
10011010110010	((dir
10011010110011	between
10011010110100	}hashTable;
10011010110101	}while
10011010110110	end-1
10011010110111	since
10011010111000	year,
10011010111001	completely
10011010111010	!(ptr->right))
10011010111011	"";
100110101111	number
10011011000000	heapArr;//our
10011011000001	heapArr[0]
10011011000010	heapArr
10011011000011	writeTo(decompressed,"\n\0");
100110110001	buffer[101];
10011011001000	home
10011011001001	(item1.isTree
1001101100101	rootSet
10011011001100	%d,
10011011001101	((int)str1[i]
10011011001110	heapify(i);
10011011001111	binary;
10011011010000	tWord;
10011011010001	(compareString(word,"\t\t\0")
10011011010010	table,
10011011010011	acting
10011011010100	accordingly
10011011010101	flag;
1001101101011	t1->word
10011011011000	accident.
10011011011001	five.
1001101101101	t1;
10011011011100	substring(char*
10011011011101	substring(char*,int,int);
1001101101111	t2->freqSet
10011011100000	//writes
10011011100001	heapArr[index].freq;
10011011100010	{//1
10011011100011	{//compress
10011011100100	((d
10011011100101	(heapSize/2)
1001101110011	heapArr[right].freq
1001101110100	sum;
1001101110101	sure
10011011101100	open(toCompress,
10011011101101	compressed\n");
10011011101110	For
10011011101111	compressed\n",temp);
100110111100	bytesRead
1001101111010	//frees
1001101111011	'd'))
10011011111000	ptr->freq;
10011011111001	decompress(char*
10011011111010	turn
10011011111011	,
1001101111110	compareString("./HuffmanCodebook\0",huffBook)
1001101111111	nodeCount++;
1001110000000	binary,boolean
10011100000010	heapInsert(heapItem);//inserts
10011100000011	heapInsert(toInsert);
10011100000100	hundred
10011100000101	hunting.
10011100000110	bstInsert(char*);//inserts
10011100000111	'0';
1001110000100	printBst(root);
10011100001010	morning,
10011100001011	BST,
1001110000110	init
1001110000111	hashcodeWord(word);
100111000100	O_CREAT
100111000101	j++;
1001110001100	waking
10011100011010	warnings)
10011100011011	prev;
10011100011100	path,int
10011100011101	people.
10011100011110	obsessive
10011100011111	occurrences
1001110010000	see
10011100100010	either
10011100100011	row.
1001110010010	combineString(temp,dir->d_name);
10011100100110	toInsert;
10011100100111	school.
10011100101000	settled
10011100101001	seven
1001110010101	Sarah.
10011100101100	so,
10011100101101	TV
10011100101110	sizeof(hashNode*));
10011100101111	Something
100111001100	1)
10011100110100	word;//word
10011100110101	He'll
10011100110110	hashcodeBin(char*
10011100110111	why
10011100111000	(item1.isTree)
10011100111001	1,
10011100111010	hour-long
10011100111011	hours
10011100111100	bstInsert("\t\0");//one
10011100111101	huffmanTree;//used
10011100111110	bstInsert(char*
10011100111111	hurts
10011101000000	heapArr[index].word
10011101000001	heapArr[index];
1001110100001	before
100111010001	tableInit(1000);
1001110100100	0);
1001110100101	sizeof(char)
100111010011	town
10011101010000	main(int
10011101010001	codeWord[index]
10011101010010	lot
10011101010011	lot,
10011101010100	longer,
10011101010101	(rootSet
1001110101011	(small
10011101011000	(hashTable*)malloc(sizeof(hashTable));
10011101011001	//stores
10011101011010	arrInit(int*
10011101011011	hashtable,
1001110101110	(argv[2][1]
10011101011110	codebook,boolean
10011101011111	me,
1001110110000	sort
10011101100010	hashSearch(word,binary,comp);
10011101100011	water.
1001110110010	There
10011101100110	hashcodeWord(char*);//computes
10011101100111	wondered
10011101101000	happened
10011101101001	any
10011101101010	false,
10011101101011	storeHuff(char*,boolean);//stores
1001110110110	\n.
1001110110111	following
10011101110000	ourselves
10011101110001	output
10011101110010	words.
10011101110011	HEAP\n");
10011101110100	(buffer[99]
10011101110101	(toFree
10011101110110	pillows,
10011101110111	place
10011101111000	(uses
10011101111001	copyString(heapArr[heapCount].word,ptr->word);
1001110111101	person
1001110111110	write
10011101111110	compressed;
10011101111111	open(output,O_WRONLY
10011110000000	//copys
10011110000001	afraid
10011110000010	tableFree(int);//frees
10011110000011	(compareString(word,"\t\t\t\0")
100111100001	//computes
1001111000100	len2
10011110001010	files\n",argv[2]);
10011110001011	files\n",temp);
1001111000110	len2)
10011110001110	access
10011110001111	finds
10011110010000	(compareString(temp2->word,word)
10011110010001	//call
1001111001001	success
10011110010100	sudden
10011110010101	//checks
1001111001011	t2;
10011110011000	read(codebook,buffer,100-readIn);
10011110011001	decompress:
10011110011010	truly
10011110011011	readFile(path);
10011110011100	bulging
10011110011101	invalid
1001111001111	doctor
100111101000	right
1001111010010	early
1001111010011	imagination
10011110101000	(int)str2[i]);//negative
10011110101001	0;//number
1001111010101	hear
1001111010110	hospital
1001111010111	hour
1001111011000	t1->right
1001111011001	//combines
10011110110100	writeTo(fd,"\n\0");
10011110110101	open(newFile,O_WRONLY
10011110110110	compress,
10011110110111	compress/decompress
100111101110	table
1001111011110	codeWord[i]
10011110111110	listDirectories(char*,int,char*);//lists
10011110111111	listDirectories(temp,mode,huffBook);
10011111000000	where
10011111000001	arr,int
10011111000010	(hashNode**)malloc(size
10011111000011	//searches
1001111100010	hashcodeBin(binary);
10011111000110	arr
10011111000111	weight
100111110010	line
10011111001100	otherwise
10011111001101	Garvey
1001111100111	outputs
10011111010000	hashInsert(word,binary,comp);
10011111010001	update
10011111010010	//proper
10011111010011	argc,
10011111010100	updates
10011111010101	hashInsert\n");
10011111010110	argv[2];
10011111010111	hashSearch(holder,NULL,true);
1001111101100	buildHuff();
1001111101101	(len2
10011111011100	index,int
10011111011101	index;
1001111101111	then
10011111100000	from)
10011111100001	from.
1001111110001	strlen(word);
1001111110010	strlen(str2);
10011111100110	to,
10011111100111	to;
10011111101000	gain
10011111101001	toInsert->binary
1001111110101	going
1001111110110	greater
1001111110111	string,
100111111100	tableFree(1000);
1001111111010	thinking
1001111111011	frequency,
10011111111000	strlen(binary);
10011111111001	(compareString(temp2->binary,binary)
10011111111010	strlen(from);
10011111111011	strlen(line);
10011111111100	table;//used
10011111111101	strlen(str);
1001111111111	t2->left
101		
11			
